/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageScalePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  maintainAspectRatio: true,
  showDimensionsWhileResizing: true,
  hideLinkSyntax: true,
  enableClickToDelete: true,
  fixImageGridSpacing: true,
  minWidth: 50,
  minHeight: 50,
  handleSize: 10,
  handleColor: "#4A9EFF"
};
var ImageScaleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Maintain aspect ratio").setDesc("Keep the image proportions when resizing").addToggle((toggle) => toggle.setValue(this.plugin.settings.maintainAspectRatio).onChange(async (value) => {
      this.plugin.settings.maintainAspectRatio = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show dimensions while resizing").setDesc("Display image dimensions during resize operation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDimensionsWhileResizing).onChange(async (value) => {
      this.plugin.settings.showDimensionsWhileResizing = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Hide link syntax").setDesc("Hide the ![[image|width]] syntax in Live Preview for cleaner display").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideLinkSyntax).onChange(async (value) => {
      this.plugin.settings.hideLinkSyntax = value;
      await this.plugin.saveSettings();
      this.plugin.updateHideLinkSyntax();
    }));
    new import_obsidian.Setting(containerEl).setName("Click to select and delete").setDesc("Click an image to select it, then press Delete or Backspace to remove").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableClickToDelete).onChange(async (value) => {
      this.plugin.settings.enableClickToDelete = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Fix image grid spacing").setDesc("Remove whitespace gaps between consecutive images in Reading mode (works with any theme)").addToggle((toggle) => toggle.setValue(this.plugin.settings.fixImageGridSpacing).onChange(async (value) => {
      this.plugin.settings.fixImageGridSpacing = value;
      await this.plugin.saveSettings();
      this.plugin.updateFixImageGridSpacing();
    }));
    new import_obsidian.Setting(containerEl).setName("Minimum width").setDesc("Minimum width for resized images (in pixels)").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.minWidth.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.minWidth = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Minimum height").setDesc("Minimum height for resized images (in pixels)").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.minHeight.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.minHeight = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Handle size").setDesc("Size of the resize handles (in pixels)").addText((text) => text.setPlaceholder("10").setValue(this.plugin.settings.handleSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.handleSize = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Handle color").setDesc("Color of the resize handles (hex color)").addText((text) => text.setPlaceholder("#4A9EFF").setValue(this.plugin.settings.handleColor).onChange(async (value) => {
      if (/^#[0-9A-F]{6}$/i.test(value)) {
        this.plugin.settings.handleColor = value;
        await this.plugin.saveSettings();
      }
    }));
  }
};

// imageResizer.ts
var import_obsidian2 = require("obsidian");
var ImageResizer = class {
  constructor(app, plugin, settings) {
    this.isResizing = false;
    this.activeImage = null;
    this.selectedImage = null;
    this.handleContainer = null;
    this.handles = [];
    this.startX = 0;
    this.startY = 0;
    this.startWidth = 0;
    this.startHeight = 0;
    this.aspectRatio = 1;
    this.currentHandle = "";
    this.processedImages = /* @__PURE__ */ new WeakSet();
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
    this.boundHandleKeydown = this.handleKeydown.bind(this);
    this.boundHandleClickOutside = this.handleClickOutside.bind(this);
    document.addEventListener("keydown", this.boundHandleKeydown);
    document.addEventListener("click", this.boundHandleClickOutside, true);
  }
  cleanup() {
    this.removeHandles();
    this.deselectImage();
    this.isResizing = false;
    this.activeImage = null;
    document.removeEventListener("keydown", this.boundHandleKeydown);
    document.removeEventListener("click", this.boundHandleClickOutside, true);
  }
  selectImage(image) {
    if (!this.settings.enableClickToDelete)
      return;
    this.deselectImage();
    this.selectedImage = image;
    image.style.outline = "2px solid #4a9eff";
    image.style.outlineOffset = "2px";
  }
  deselectImage() {
    if (this.selectedImage) {
      this.selectedImage.style.outline = "";
      this.selectedImage.style.outlineOffset = "";
      this.selectedImage = null;
    }
  }
  handleKeydown(e) {
    if (!this.selectedImage)
      return;
    if (e.key === "Delete" || e.key === "Backspace") {
      e.preventDefault();
      e.stopPropagation();
      this.deleteSelectedImage();
    } else if (e.key === "Escape") {
      this.deselectImage();
    }
  }
  handleClickOutside(e) {
    const target = e.target;
    if (target.tagName === "IMG" || target.closest(".image-resize-handle-container")) {
      return;
    }
    this.deselectImage();
  }
  async deleteSelectedImage() {
    if (!this.selectedImage)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!view)
      return;
    const editor = view.editor;
    const content = editor.getValue();
    const lines = content.split("\n");
    const imgSrc = this.selectedImage.getAttribute("src") || "";
    const imgAlt = this.selectedImage.getAttribute("alt") || "";
    let deleted = false;
    for (let i = 0; i < lines.length; i++) {
      const match = lines[i].match(/!\[\[([^\]]+?)(?:\|\d+(?:x\d+)?)?\]\]/);
      if (match) {
        const imagePath = match[1];
        if (imgAlt.includes(imagePath) || imagePath.includes(imgAlt) || imgSrc.includes(encodeURIComponent(imagePath))) {
          lines[i] = lines[i].replace(/!\[\[([^\]]+?)(?:\|\d+(?:x\d+)?)?\]\]/, "");
          deleted = true;
          break;
        }
      }
    }
    if (deleted) {
      this.deselectImage();
      editor.setValue(lines.join("\n"));
      new import_obsidian2.Notice("Image deleted");
    }
  }
  toggleImageResize(img) {
  }
  makeImageResizable(img, context) {
    if (img.tagName !== "IMG")
      return;
    if (this.processedImages.has(img))
      return;
    this.processedImages.add(img);
    const image = img;
    image.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      this.selectImage(image);
    }, { capture: true });
    image.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    }, { capture: true });
    image.addEventListener("mouseenter", () => {
      if (this.isResizing)
        return;
      this.showHandles(image);
    });
    image.addEventListener("mouseleave", (e) => {
      if (this.isResizing)
        return;
      const relatedTarget = e.relatedTarget;
      if (!(relatedTarget == null ? void 0 : relatedTarget.closest(".image-resize-handle-container"))) {
        this.removeHandles();
      }
    });
  }
  showHandles(image) {
    if (this.activeImage === image && this.handleContainer)
      return;
    this.removeHandles();
    this.activeImage = image;
    this.aspectRatio = image.naturalWidth / image.naturalHeight;
    const rect = image.getBoundingClientRect();
    this.handleContainer = document.createElement("div");
    this.handleContainer.className = "image-resize-handle-container";
    this.handleContainer.style.cssText = `
			position: fixed;
			top: ${rect.top}px;
			left: ${rect.left}px;
			width: ${rect.width}px;
			height: ${rect.height}px;
			pointer-events: none;
			z-index: 10000;
		`;
    document.body.appendChild(this.handleContainer);
    const handle = document.createElement("div");
    handle.className = "image-resize-handle";
    handle.style.cssText = `
			position: absolute;
			bottom: 4px;
			right: 4px;
			width: 24px;
			height: 24px;
			background: rgba(0, 0, 0, 0.6);
			border-radius: 4px;
			cursor: se-resize;
			pointer-events: auto;
			display: flex;
			align-items: center;
			justify-content: center;
		`;
    handle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12" fill="white">
			<circle cx="2" cy="2" r="1.5"/>
			<circle cx="6" cy="2" r="1.5"/>
			<circle cx="10" cy="2" r="1.5"/>
			<circle cx="2" cy="6" r="1.5"/>
			<circle cx="6" cy="6" r="1.5"/>
			<circle cx="10" cy="6" r="1.5"/>
			<circle cx="2" cy="10" r="1.5"/>
			<circle cx="6" cy="10" r="1.5"/>
			<circle cx="10" cy="10" r="1.5"/>
		</svg>`;
    handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log("[ImageResizer] Handle clicked: se");
      this.startResize(e, "se");
    });
    this.handleContainer.appendChild(handle);
    this.handles.push(handle);
    this.handleContainer.addEventListener("mouseleave", (e) => {
      if (this.isResizing)
        return;
      const relatedTarget = e.relatedTarget;
      if (relatedTarget !== this.activeImage) {
        this.removeHandles();
      }
    });
  }
  removeHandles() {
    if (this.isResizing)
      return;
    if (this.handleContainer) {
      this.handleContainer.remove();
      this.handleContainer = null;
    }
    this.handles = [];
    this.activeImage = null;
  }
  updateHandlePosition() {
    if (!this.activeImage || !this.handleContainer)
      return;
    const rect = this.activeImage.getBoundingClientRect();
    this.handleContainer.style.top = `${rect.top}px`;
    this.handleContainer.style.left = `${rect.left}px`;
    this.handleContainer.style.width = `${rect.width}px`;
    this.handleContainer.style.height = `${rect.height}px`;
  }
  startResize(e, corner) {
    if (!this.activeImage)
      return;
    this.isResizing = true;
    this.currentHandle = corner;
    this.startX = e.clientX;
    this.startY = e.clientY;
    this.startWidth = this.activeImage.width || this.activeImage.clientWidth;
    this.startHeight = this.activeImage.height || this.activeImage.clientHeight;
    this.activeImage.style.outline = "2px solid #4a9eff";
    const onMouseMove = (e2) => {
      if (!this.isResizing || !this.activeImage)
        return;
      const deltaX = e2.clientX - this.startX;
      let newWidth = Math.max(this.startWidth + deltaX, this.settings.minWidth);
      const newHeight = newWidth / this.aspectRatio;
      this.activeImage.style.width = `${Math.round(newWidth)}px`;
      this.activeImage.style.height = `${Math.round(newHeight)}px`;
      this.updateHandlePosition();
    };
    const onMouseUp = async () => {
      console.log("[ImageResizer] mouseup - saving");
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      if (this.activeImage) {
        this.activeImage.style.outline = "";
        const width = Math.round(this.activeImage.clientWidth);
        const imageToUpdate = this.activeImage;
        this.isResizing = false;
        this.removeHandles();
        await this.updateMarkdown(imageToUpdate, width);
      } else {
        this.isResizing = false;
        this.removeHandles();
      }
    };
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  }
  async updateMarkdown(img, width) {
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!view)
      return;
    const editor = view.editor;
    const content = editor.getValue();
    const lines = content.split("\n");
    let updated = false;
    for (let i = 0; i < lines.length; i++) {
      let newLine = lines[i];
      newLine = newLine.replace(/!\[\[([^\]]+?)(?:\|\d+(?:x\d+)?)?\]\]/g, (match, path) => {
        updated = true;
        return `![[${path}|${width}]]`;
      });
      if (newLine !== lines[i]) {
        lines[i] = newLine;
      }
    }
    if (updated) {
      editor.setValue(lines.join("\n"));
      new import_obsidian2.Notice(`Resized to ${width}px`);
    }
  }
};

// main.ts
var ImageScalePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.observer = null;
  }
  async onload() {
    await this.loadSettings();
    this.resizer = new ImageResizer(this.app, this, this.settings);
    this.addSettingTab(new ImageScaleSettingTab(this.app, this));
    this.updateHideLinkSyntax();
    this.updateFixImageGridSpacing();
    this.registerMarkdownPostProcessor((element, context) => {
      const images = element.querySelectorAll("img");
      images.forEach((img) => {
        this.resizer.makeImageResizable(img, context);
      });
    });
    this.app.workspace.onLayoutReady(() => {
      this.startObserving();
      this.processAllImages();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.processAllImages();
      })
    );
    this.addCommand({
      id: "reset-image-size",
      name: "Reset size to original",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const imageRegex = /!\[\[([^\]]+?)(?:\|\d+)?\]\]/g;
        let match;
        while ((match = imageRegex.exec(line)) !== null) {
          const start = match.index;
          const end = start + match[0].length;
          if (cursor.ch >= start && cursor.ch <= end) {
            const path = match[1].split("|")[0];
            const newImageMd = `![[${path}]]`;
            editor.replaceRange(
              newImageMd,
              { line: cursor.line, ch: start },
              { line: cursor.line, ch: end }
            );
            new import_obsidian3.Notice("Image size reset");
            return;
          }
        }
        new import_obsidian3.Notice("No image found at cursor");
      }
    });
  }
  onunload() {
    if (this.observer) {
      this.observer.disconnect();
    }
    document.body.classList.remove("hide-image-link-syntax");
    document.body.classList.remove("fix-image-grid-spacing");
  }
  updateHideLinkSyntax() {
    if (this.settings.hideLinkSyntax) {
      document.body.classList.add("hide-image-link-syntax");
    } else {
      document.body.classList.remove("hide-image-link-syntax");
    }
  }
  updateFixImageGridSpacing() {
    if (this.settings.fixImageGridSpacing) {
      document.body.classList.add("fix-image-grid-spacing");
    } else {
      document.body.classList.remove("fix-image-grid-spacing");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  startObserving() {
    this.observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach((node) => {
            if (node instanceof HTMLElement) {
              const images = node.querySelectorAll("img");
              images.forEach((img) => {
                this.resizer.makeImageResizable(img, null);
              });
              if (node.tagName === "IMG") {
                this.resizer.makeImageResizable(node, null);
              }
            }
          });
        }
      }
    });
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  processAllImages() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (!activeView)
      return;
    const container = activeView.contentEl;
    const images = container.querySelectorAll("img");
    images.forEach((img) => {
      if (!img.dataset.imageScaleProcessed) {
        this.resizer.makeImageResizable(img, null);
      }
    });
  }
};
